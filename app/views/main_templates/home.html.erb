<!-- app/views/main_templates/home.html.erb -->
<h1>Dictation App</h1>

<!-- Action Log Container -->
<% if @action_log.present? && @action_log.any? %>
  <div style="background-color: #f0f8ff; padding: 10px; border-radius: 5px;">
    <h3>Action Log:</h3>
    <ul>
      <% @action_log.each do |entry| %>
        <% if entry['url'] %>
          <li>
            <strong><%= entry['message'] %></strong>: 
            <a href="<%= entry['url'] %>" target="_blank">View in Notion</a>
          </li>
        <% else %>
          <li><%= entry['message'] %></li>
        <% end %>
      <% end %>
    </ul>
  </div>
<% else %>
  <p>No recent activity.</p>
<% end %>



<input type="checkbox" id="skip_confirmation" name="skip_confirmation" value="1" checked>
<label for="skip_confirmation">Skip confirmation step ("hardcore mode")</label>
<br><br>

<button id="record-button" aria-label="Hold to start recording">Hold to Record</button>
<div id="recording-indicator" style="display: none; color: red; font-weight: bold; margin-top: 10px;">
  Recording...
</div>

<form action="/submit" method="post">
  <input type="hidden" name="authenticity_token" value="<%= form_authenticity_token %>">
  <label for="input_box"></label>
  <textarea id="input_box" name="input" rows="3" placeholder="Dictation will appear here..." lang="en"></textarea>
  <br>
  <button type="submit">Submit</button>
</form>

<h3>Example prompts</h3>
<ol>
  <li>I need to add cumin to my shopping list</li>
  <li>I spoke to Lydia Wang from my Digital Marketing class. We both have to finish the LinkedIn social media ads for SearchStax by Friday next week.</li>
  <li>I spoke to Jivika. She can get me an interview with Notion.</li>
  <li>I had a brilliant conversation with Professor Lil Mohan. We had a great conversation about the deterioration of incoming MBA students, year over-year.</li>
  <li>Lorna just reminded me that I need to pick her up from the airport on Friday.</li>
  <li>Need to buy cumin, black pepper, 1 yellow onion, 2 tomatoes, 4 eggplants, and a bottle of whiskey.</li>
  <li>I was sitting next to Paul Kozhipatt in my Managing the Workplace class. He advised me to finish it before applying to Apple.</li>
  <li>Dinner plan tonight: Lebanese Pita Bread, Manakish, Lamb Tagine, Roasted Garlic Hummus, and Roasted Parsnips.</li>
</ol>

<!-- <script src="https://cdn.webrtc-experiment.com/RecordRTC.js"></script> -->
<script>
  let mediaRecorder;
  let audioChunks = [];
  let stream;

  const recordButton = document.getElementById('record-button');
  const inputBox = document.getElementById('input_box');
  const hardcoreModeCheckbox = document.getElementById('skip_confirmation');
  const recordingIndicator = document.getElementById('recording-indicator');
  const actionLogContainer = document.getElementById('action-log-container');

  // Function to sanitize HTML to prevent XSS
  const sanitizeHTML = (str) => {
    const temp = document.createElement('div');
    temp.textContent = str;
    return temp.innerHTML;
  };

  // Function to start recording
  const startRecording = async () => {
    console.log('Attempting to start recording');

    try {
      // Check microphone permission
      let permissionStatus = 'prompt';
      if (navigator.permissions) {
        try {
          const status = await navigator.permissions.query({ name: 'microphone' });
          permissionStatus = status.state;
        } catch (err) {
          console.warn('Permissions API not fully supported:', err);
        }
      }

      if (permissionStatus === 'denied') {
        alert('Microphone access denied. Please enable it in your device settings.');
        return;
      }

      // Request media
      stream = await navigator.mediaDevices.getUserMedia({ audio: true });
      console.log('Microphone access granted');

      mediaRecorder = new MediaRecorder(stream, { mimeType: 'audio/webm' });

      mediaRecorder.ondataavailable = event => {
        if (event.data.size > 0) {
          audioChunks.push(event.data);
        }
      };

      mediaRecorder.onstop = () => {
        const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
        audioChunks = []; // Reset for next recording

        console.log('Audio blob size:', audioBlob.size);

        if (audioBlob.size < 1000) { // Arbitrary threshold (e.g., 1KB)
          alert('Recorded audio is too short. Please try again.');
          return;
        }

        const formData = new FormData();
        formData.append('audio_file', audioBlob, 'recording.webm');
        formData.append('authenticity_token', '<%= form_authenticity_token %>');

        const hardcoreMode = hardcoreModeCheckbox.checked ? '1' : '0';
        formData.append('skip_confirmation', hardcoreMode);

        const fetchOptions = {
          method: 'POST',
          body: formData
        };

        if (hardcoreMode === '1') {
          console.log('Submitting audio in hardcore mode');
          fetch('/upload_audio', fetchOptions)
            .then(response => response.json())
            .then(data => {
              console.log('Response received:', data);
              if (data.success) {
                if (data.action_log && Array.isArray(data.action_log)) {
                  displayActionLog(data.action_log);
                }
              } else {
                alert(data.error || 'An error occurred during processing.');
                console.error('Processing failed:', data.error);
              }
            })
            .catch(error => {
              console.error('Fetch error:', error);
              alert('An error occurred during processing.');
            });
        } else {
          console.log('Submitting audio in normal mode');
          fetch('/upload_audio', fetchOptions)
            .then(response => response.json())
            .then(data => {
              console.log('Response received:', data);
              if (data.transcription) {
                inputBox.value = data.transcription;
                console.log('Textarea updated with transcription');
              } else {
                alert('No transcription received.');
                console.warn('No transcription in response');
              }
            })
            .catch(error => {
              console.error('Fetch error:', error);
              alert('An error occurred during transcription.');
            });
        }

        // Stop all audio tracks to release the microphone
        if (stream) {
          stream.getTracks().forEach(track => track.stop());
          console.log('Audio tracks stopped');
        }
      };

      mediaRecorder.onerror = event => {
        console.error('MediaRecorder error:', event.error);
        alert('An error occurred during recording.');
        recordingIndicator.style.display = 'none';
        recordButton.disabled = false;
      };

      mediaRecorder.start();
      recordingIndicator.style.display = 'block';
      recordButton.disabled = true;
      console.log('Recording started');
    } catch (err) {
      console.error('Error accessing microphone:', err);
      alert('An error occurred while accessing the microphone.');
    }
  };

  // Function to stop recording
  const stopRecording = () => {
    if (!mediaRecorder) return;

    console.log('Stopping recording');
    mediaRecorder.stop();
    recordingIndicator.style.display = 'none';
    recordButton.disabled = false;
  };

  // Function to display the Action Log with descriptive messages and hyperlinks
  const displayActionLog = (actionLog) => {
    // Remove existing dynamic-action-log if present to avoid duplicates
    let existingActionLogDiv = document.getElementById('dynamic-action-log');
    if (existingActionLogDiv) {
      existingActionLogDiv.remove();
    }

    // Create a new Action Log section
    let actionLogDiv = document.createElement('div');
    actionLogDiv.id = 'dynamic-action-log';
    actionLogDiv.style.backgroundColor = '#f0f8ff';
    actionLogDiv.style.padding = '10px';
    actionLogDiv.style.borderRadius = '5px';
    actionLogDiv.style.marginTop = '20px';

    let header = document.createElement('h3');
    header.textContent = 'Success!';
    actionLogDiv.appendChild(header);

    let pagesCreatedHeader = document.createElement('h4');
    pagesCreatedHeader.textContent = 'Pages Created:';
    actionLogDiv.appendChild(pagesCreatedHeader);

    let ulPages = document.createElement('ul');

    actionLog.forEach(entry => {
      if (entry.url) {
        let li = document.createElement('li');
        li.innerHTML = `${sanitizeHTML(entry.message)}: <a href="${sanitizeHTML(entry.url)}" target="_blank">View in Notion</a>`;
        ulPages.appendChild(li);
      }
    });

    actionLogDiv.appendChild(ulPages);

    // Handle relations added if any
    let relations = actionLog.filter(entry => entry.message.startsWith('Updated'));
    if (relations.length > 0) {
      let relationsHeader = document.createElement('h4');
      relationsHeader.textContent = 'Relations Added:';
      actionLogDiv.appendChild(relationsHeader);

      let ulRelations = document.createElement('ul');

      relations.forEach(entry => {
        if (entry.url) {
          let li = document.createElement('li');
          li.innerHTML = `${sanitizeHTML(entry.message)}: <a href="${sanitizeHTML(entry.url)}" target="_blank">View in Notion</a>`;
          ulRelations.appendChild(li);
        } else {
          let li = document.createElement('li');
          li.textContent = sanitizeHTML(entry.message);
          ulRelations.appendChild(li);
        }
      });

      actionLogDiv.appendChild(ulRelations);
    }

    actionLogContainer.prepend(actionLogDiv);
  };

  // Event listeners for pointer events
  recordButton.addEventListener('pointerdown', (event) => {
    // Prevent default behavior to avoid unintended interactions
    event.preventDefault();
    startRecording();
  });

  recordButton.addEventListener('pointerup', (event) => {
    event.preventDefault();
    stopRecording();
  });

  // Optional: Handle pointer cancel (e.g., when touch is interrupted)
  recordButton.addEventListener('pointercancel', (event) => {
    event.preventDefault();
    stopRecording();
  });

  // Prevent context menu on long press (especially on mobile)
  recordButton.addEventListener('contextmenu', (event) => {
    event.preventDefault();
  });

  // Accessibility: Handle keyboard events (Space and Enter)
  recordButton.addEventListener('keydown', (event) => {
    if (event.key === ' ' || event.key === 'Enter') {
      event.preventDefault();
      startRecording();
    }
  });

  recordButton.addEventListener('keyup', (event) => {
    if (event.key === ' ' || event.key === 'Enter') {
      event.preventDefault();
      stopRecording();
    }
});
</script>
